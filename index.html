<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Moon Runner - Lunar Rover Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      border: 2px solid #333;
      image-rendering: crisp-edges;
      touch-action: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
const canvas = document.getElementById('canvas');
const cx = canvas.getContext('2d');

// Canvas setup: 420x746 portrait
canvas.width = 420;
canvas.height = 746;

// Resize to fit viewport
function resizeCanvas() {
  const maxW = window.innerWidth - 20;
  const maxH = window.innerHeight - 20;
  const scale = Math.min(maxW / 420, maxH / 746);
  canvas.style.width = (420 * scale) + 'px';
  canvas.style.height = (746 * scale) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Drawing helpers
function pill(cx, x, y, w, h, r, fill, stroke, lw) {
  cx.fillStyle = fill;
  cx.strokeStyle = stroke;
  cx.lineWidth = lw || 1;
  cx.beginPath();
  cx.roundRect(x, y, w, h, r);
  cx.fill();
  if (stroke) cx.stroke();
}

function circle(cx, x, y, r, fill, stroke, lw) {
  cx.fillStyle = fill;
  cx.strokeStyle = stroke;
  cx.lineWidth = lw || 1;
  cx.beginPath();
  cx.arc(x, y, r, 0, Math.PI * 2);
  cx.fill();
  if (stroke) cx.stroke();
}

function drawCuteStar(cx, x, y, r, color, outColor) {
  cx.fillStyle = color;
  cx.strokeStyle = outColor;
  cx.lineWidth = 2;
  cx.beginPath();
  for (let i = 0; i < 10; i++) {
    const angle = (i * Math.PI) / 5 - Math.PI / 2;
    const rad = i % 2 === 0 ? r : r * 0.4;
    const px = x + Math.cos(angle) * rad;
    const py = y + Math.sin(angle) * rad;
    if (i === 0) cx.moveTo(px, py);
    else cx.lineTo(px, py);
  }
  cx.closePath();
  cx.fill();
  cx.stroke();
}

// Game stages
const stages = [
  { name: 'Mare Tranquillitatis', sub: '고요의 바다', target: 1000, speed: 1.0, obsMul: 1.0, enMul: 1.0, diff: 'EASY', color: '#60d060' },
  { name: 'Oceanus Procellarum', sub: '폭풍의 대양', target: 2500, speed: 1.15, obsMul: 1.3, enMul: 0.9, diff: 'NORMAL', color: '#50a0ff' },
  { name: 'Crater Copernicus', sub: '코페르니쿠스 분화구', target: 4500, speed: 1.3, obsMul: 1.6, enMul: 0.8, diff: 'HARD', color: '#ffa030' },
  { name: 'Far Side Darklands', sub: '달의 뒷면', target: 7000, speed: 1.45, obsMul: 1.9, enMul: 0.7, diff: 'HARDER', color: '#e050a0' },
  { name: 'South Pole Aitken', sub: '남극 에이트킨 분지', target: 10000, speed: 1.6, obsMul: 2.2, enMul: 0.6, diff: 'EXTREME', color: '#ff4050' },
];

const lunarFacts = [
  { title: 'GRAVITY', type: 'LUNAR FACT \u2022 PHYSICS', text: 'The Moon has 1/6th the gravity of Earth. A 180lb astronaut weighs only 30lb on the lunar surface!' },
  { title: 'DUST', type: 'LUNAR FACT \u2022 MATERIAL', text: 'Moon dust is extremely abrasive and can damage equipment. Its particles are sharp and electrostatically charged.' },
  { title: 'TEMPERATURE', type: 'LUNAR FACT \u2022 CLIMATE', text: 'Lunar surface temps swing from -173\u00b0C in shadow to 127\u00b0C in sunlight. Extreme conditions test rovers daily.' },
  { title: 'CRATERS', type: 'LUNAR FACT \u2022 GEOLOGY', text: 'The Moon has over 300,000 craters larger than 1km. They reveal billions of years of cosmic impacts.' },
  { title: 'ROTATION', type: 'LUNAR FACT \u2022 ASTRONOMY', text: 'The Moon is tidally locked to Earth. We always see the same face\u2014the far side remained unknown until 1959.' },
  { title: 'WATER ICE', type: 'LUNAR FACT \u2022 DISCOVERY', text: 'In 2008, water ice was detected in lunar soil. Permanently shadowed craters at the poles hold ancient frozen water.' },
  { title: 'REGOLITH', type: 'LUNAR FACT \u2022 GEOLOGY', text: "The Moon's surface layer is called regolith. It's ancient powdered rock created by billions of years of asteroid bombardment." },
  { title: 'SEISMIC', type: 'LUNAR FACT \u2022 SCIENCE', text: 'Moonquakes occur regularly but are much weaker than earthquakes. The Moon is still slowly cooling and contracting.' },
  { title: 'LAVA TUBES', type: 'LUNAR FACT \u2022 GEOLOGY', text: 'Massive lava tubes beneath the surface could shelter future lunar colonies from radiation and temperature extremes.' },
  { title: 'HARVEST MOON', type: 'LUNAR FACT \u2022 CULTURE', text: "The Harvest Moon appears larger and brighter than usual. This optical illusion is due to our brain's size perception." },
  { title: 'DARK SIDE', type: 'LUNAR FACT \u2022 MYSTERY', text: "The far side is actually brighter! It's called \"dark\" because we couldn't see it from Earth until satellites revealed it." },
  { title: 'FORMATION', type: 'LUNAR FACT \u2022 HISTORY', text: 'Scientists believe the Moon formed 4.51 billion years ago when a Mars-sized object collided with young Earth.' },
];

// Game state
const game = {
  state: 'title',
  canvas: canvas,
  ox: 0,
  vy: 0,
  distance: 0,
  bestDistance: 0,
  roverId: 0,
  stage: 0,
  health: 3,
  boost: 100,
  fr: 0,
  roverX: 80,
  totalDistance: 0,
  jumps: 0,
  showJumpHint: 120,
};

const rovers = [
  { key: 'sojourner', name: 'SOJOURNER', color: '#f0d040', spd: 2, arm: 1, bst: 2, unlocked: true },
  { key: 'curiosity', name: 'CURIOSITY', color: '#4090e0', spd: 3, arm: 3, bst: 1, unlocked: false },
  { key: 'perseverance', name: 'PERSEVERANCE', color: '#e05030', spd: 2, arm: 4, bst: 3, unlocked: false },
];

// Draw rover helpers
function drawSojourner(cx, x, y, scale) {
  const s = scale;
  // Body
  pill(cx, x + 5*s, y + 10*s, 30*s, 12*s, 3*s, '#f0d040', '#d0a000', 2*s);
  // Solar panel hat
  pill(cx, x + 8*s, y + 5*s, 24*s, 4*s, 2*s, '#ffeb99', '#d0a000', 1*s);
  // Antenna
  circle(cx, x + 28*s, y + 3*s, 3*s, '#ff3030', '#a00000', 1*s);
  cx.strokeStyle = '#b8a000';
  cx.lineWidth = 2*s;
  cx.beginPath();
  cx.moveTo(x + 28*s, y + 8*s);
  cx.lineTo(x + 28*s, y + 2*s);
  cx.stroke();
  // Wheels
  circle(cx, x + 10*s, y + 23*s, 3*s, '#444', '#222', 1*s);
  circle(cx, x + 20*s, y + 23*s, 3*s, '#444', '#222', 1*s);
  circle(cx, x + 30*s, y + 23*s, 3*s, '#444', '#222', 1*s);
  // Camera sensor (no eyes!)
  pill(cx, x + 15*s, y + 10*s, 10*s, 4*s, 1*s, '#888', '#333', 1*s);
  circle(cx, x + 18*s, y + 11*s, 1.5*s, '#aaa', '#333', 0.5*s);
}

function drawCuriosity(cx, x, y, scale) {
  const s = scale;
  // Body
  pill(cx, x + 5*s, y + 12*s, 35*s, 14*s, 3*s, '#4090e0', '#1050a0', 2*s);
  // Mast
  pill(cx, x + 19*s, y + 2*s, 6*s, 12*s, 2*s, '#666', '#333', 1*s);
  // Mast camera (rectangular sensor, no eyes!)
  pill(cx, x + 17*s, y + 0*s, 10*s, 5*s, 1*s, '#888', '#333', 1*s);
  circle(cx, x + 20*s, y + 1*s, 1.5*s, '#aaa', '#333', 0.5*s);
  // RTG cylinder
  circle(cx, x + 37*s, y + 14*s, 4*s, '#ffa030', '#b86000', 1*s);
  // Robot arm
  cx.strokeStyle = '#555';
  cx.lineWidth = 2*s;
  cx.beginPath();
  cx.moveTo(x + 35*s, y + 18*s);
  cx.lineTo(x + 42*s, y + 12*s);
  cx.stroke();
  // Wheels
  circle(cx, x + 10*s, y + 27*s, 3.5*s, '#333', '#222', 1*s);
  circle(cx, x + 20*s, y + 27*s, 3.5*s, '#333', '#222', 1*s);
  circle(cx, x + 32*s, y + 27*s, 3.5*s, '#333', '#222', 1*s);
}

function drawPerseverance(cx, x, y, scale) {
  const s = scale;
  // Armored body
  pill(cx, x + 3*s, y + 10*s, 40*s, 16*s, 4*s, '#e05030', '#a03020', 2*s);
  // SuperCam mast
  pill(cx, x + 21*s, y - 2*s, 5*s, 14*s, 2*s, '#555', '#222', 1*s);
  // Mast camera housing (rectangular sensor, no eyes!)
  pill(cx, x + 18*s, y - 4*s, 11*s, 6*s, 1*s, '#777', '#333', 1*s);
  circle(cx, x + 22*s, y - 2*s, 1.5*s, '#aaa', '#333', 0.5*s);
  // Microphone ball
  circle(cx, x + 23*s, y - 6*s, 2.5*s, '#ffcc00', '#b8a000', 1*s);
  // Robot arm
  cx.strokeStyle = '#555';
  cx.lineWidth = 2*s;
  cx.beginPath();
  cx.moveTo(x + 40*s, y + 16*s);
  cx.lineTo(x + 48*s, y + 10*s);
  cx.stroke();
  // Helicopter drone (simple body + rotor, NO face!)
  circle(cx, x + 45*s, y + 5*s, 2*s, '#cccccc', '#666', 1*s);
  cx.strokeStyle = '#666';
  cx.lineWidth = 1.5*s;
  cx.beginPath();
  cx.moveTo(x + 43*s, y + 5*s);
  cx.lineTo(x + 47*s, y + 5*s);
  cx.stroke();
  // Wheels
  circle(cx, x + 8*s, y + 27*s, 4*s, '#222', '#000', 1*s);
  circle(cx, x + 20*s, y + 27*s, 4*s, '#222', '#000', 1*s);
  circle(cx, x + 35*s, y + 27*s, 4*s, '#222', '#000', 1*s);
}

function drawRover(cx, key, x, y, scale) {
  if (key === 'sojourner') drawSojourner(cx, x, y, scale);
  else if (key === 'curiosity') drawCuriosity(cx, x, y, scale);
  else if (key === 'perseverance') drawPerseverance(cx, x, y, scale);
}

// Background drawing
function drawBg() {
  const grad = cx.createLinearGradient(0, 0, 0, 540);
  grad.addColorStop(0, '#0a0428');
  grad.addColorStop(1, '#302090');
  cx.fillStyle = grad;
  cx.fillRect(0, 0, 420, 540);

  // Stars (twinkling)
  cx.fillStyle = '#fff';
  for (let i = 0; i < 50; i++) {
    const sx = (i * 91) % 420;
    const sy = (i * 73) % 400;
    const twinkle = Math.sin(game.fr * 0.03 + i) * 0.5 + 0.5;
    cx.globalAlpha = 0.3 + twinkle * 0.4;
    cx.beginPath();
    cx.arc(sx, sy, 1, 0, Math.PI * 2);
    cx.fill();
  }
  cx.globalAlpha = 1;

  // Earth (fixed position)
  circle(cx, 60, 100, 25, '#4a90e2', '#2050a0', 2);
  cx.fillStyle = '#4a90e2';
  cx.beginPath();
  cx.arc(55, 95, 5, 0, Math.PI * 2);
  cx.fill();

  // Saturn-like planet (fixed position)
  circle(cx, 360, 130, 18, '#d4a574', '#8b6f47', 2);
  cx.strokeStyle = '#8b6f47';
  cx.lineWidth = 3;
  cx.beginPath();
  cx.arc(360, 130, 28, 0, Math.PI * 2);
  cx.stroke();
}

// Ground drawing
function drawGround() {
  const stageSpeed = stages[game.stage].speed;
  const scrollSpeed = 1.0 * stageSpeed;
  const baseY = 540;
  const ox = game.ox * 0.4;

  // Mountain parallax 1 (10%)
  cx.fillStyle = '#2a2060';
  cx.beginPath();
  cx.moveTo(0, baseY - 60);
  for (let i = 0; i < 435; i++) {
    const h = Math.sin((i + ox * 0.1) * 0.01) * 15 + 20;
    cx.lineTo(i, baseY - 60 - h);
  }
  cx.lineTo(420, baseY);
  cx.lineTo(0, baseY);
  cx.closePath();
  cx.fill();

  // Mountain parallax 2 (20%)
  cx.fillStyle = '#3a3080';
  cx.beginPath();
  cx.moveTo(0, baseY - 30);
  for (let i = 0; i < 435; i++) {
    const h = Math.sin((i + ox * 0.2) * 0.008) * 12 + 15;
    cx.lineTo(i, baseY - 30 - h);
  }
  cx.lineTo(420, baseY);
  cx.lineTo(0, baseY);
  cx.closePath();
  cx.fill();

  // Moon ground (scrolls at 40% \u2014 ox is already game.ox * 0.4)
  const moonOx = ox;
  const grad = cx.createLinearGradient(0, baseY, 0, 746);
  grad.addColorStop(0, '#d0c8b8');
  grad.addColorStop(1, '#a09888');
  cx.fillStyle = grad;
  cx.beginPath();
  cx.moveTo(0, baseY);
  for (let i = 0; i < 435; i++) {
    const wave = Math.sin((i + moonOx) * 0.005) * 8 +
                 Math.sin((i + moonOx) * 0.015) * 4 +
                 Math.sin((i + moonOx) * 0.04) * 2;
    cx.lineTo(i, baseY + wave);
  }
  cx.lineTo(420, 746);
  cx.lineTo(0, 746);
  cx.closePath();
  cx.fill();

  // Surface line
  cx.strokeStyle = '#8a8278';
  cx.lineWidth = 2;
  cx.beginPath();
  cx.moveTo(0, baseY);
  for (let i = 0; i < 435; i++) {
    const wave = Math.sin((i + moonOx) * 0.005) * 8 +
                 Math.sin((i + moonOx) * 0.015) * 4 +
                 Math.sin((i + moonOx) * 0.04) * 2;
    cx.lineTo(i, baseY + wave);
  }
  cx.stroke();

  // Craters
  for (let i = 0; i < 8; i++) {
    const cx_pos = ((i * 150 - moonOx) % 420 + 420) % 420;
    cx.fillStyle = '#7a7268';
    cx.beginPath();
    cx.ellipse(cx_pos, baseY + 20, 20, 10, 0, 0, Math.PI * 2);
    cx.fill();
  }
}

// Obstacle/crystal drawing
function drawObstacle(obs) {
  const baseY = 540;
  const ox = game.ox * 0.4;
  const y = baseY + Math.sin((obs.x + ox) * 0.005) * 8 +
                    Math.sin((obs.x + ox) * 0.015) * 4 +
                    Math.sin((obs.x + ox) * 0.04) * 2 - obs.h;

  if (obs.type === 'rock') {
    cx.fillStyle = '#8a7a6a';
    cx.beginPath();
    cx.moveTo(obs.x, y);
    cx.lineTo(obs.x + 15, y - 8);
    cx.lineTo(obs.x + 20, y);
    cx.lineTo(obs.x + 15, y + 3);
    cx.closePath();
    cx.fill();
    cx.strokeStyle = '#a09a8a';
    cx.lineWidth = 2;
    cx.stroke();
  } else if (obs.type === 'water') {
    cx.fillStyle = '#3a7aff';
    cx.beginPath();
    cx.ellipse(obs.x + 10, y + 2, 12, 6, 0, 0, Math.PI * 2);
    cx.fill();
    cx.strokeStyle = '#1a5adf';
    cx.lineWidth = 2;
    cx.stroke();
  } else if (obs.type === 'crater') {
    cx.fillStyle = '#6a5a4a';
    cx.beginPath();
    cx.ellipse(obs.x + 10, y + 4, 14, 8, 0, 0, Math.PI * 2);
    cx.fill();
    cx.strokeStyle = '#4a3a2a';
    cx.lineWidth = 2;
    cx.stroke();
  }
}

function drawCrystal(cryst) {
  const baseY = 540;
  const ox = game.ox * 0.4;
  const y = baseY + Math.sin((cryst.x + ox) * 0.005) * 8 +
                    Math.sin((cryst.x + ox) * 0.015) * 4 +
                    Math.sin((cryst.x + ox) * 0.04) * 2 - 20;

  cx.fillStyle = '#ffff00';
  cx.beginPath();
  cx.moveTo(cryst.x, y);
  cx.lineTo(cryst.x + 8, y - 10);
  cx.lineTo(cryst.x + 16, y);
  cx.lineTo(cryst.x + 8, y + 10);
  cx.closePath();
  cx.fill();
  cx.strokeStyle = '#ccaa00';
  cx.lineWidth = 2;
  cx.stroke();

  // Sparkle
  const sparkle = Math.sin(game.fr * 0.1) * 0.5 + 0.5;
  cx.globalAlpha = sparkle;
  cx.fillStyle = '#ffffff';
  cx.beginPath();
  cx.arc(cryst.x + 5, y - 5, 2, 0, Math.PI * 2);
  cx.fill();
  cx.globalAlpha = 1;
}

// HUD drawing
function drawHUD() {
  // Dark bar background
  cx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  cx.fillRect(0, 0, 420, 60);
  cx.strokeStyle = '#d0a000';
  cx.lineWidth = 2;
  cx.beginPath();
  cx.moveTo(0, 55);
  cx.lineTo(420, 55);
  cx.stroke();

  // Mini rover
  drawRover(cx, rovers[game.roverId].key, 8, 8, 0.4);

  // Hearts
  cx.fillStyle = '#ff3030';
  for (let i = 0; i < game.health; i++) {
    pill(cx, 60 + i * 15, 18, 10, 10, 2, '#ff6666', '#cc0000', 1);
  }

  // Stage name
  cx.fillStyle = '#d0a000';
  cx.font = 'bold 14px Arial';
  cx.fillText(stages[game.stage].name, 120, 30);

  // Distance (right)
  cx.fillStyle = '#ffffff';
  cx.font = 'bold 12px Arial';
  const distStr = Math.floor(game.distance) + 'm';
  cx.textAlign = 'right';
  cx.fillText(distStr, 410, 30);
  cx.textAlign = 'left';

  // Progress bar
  const progress = Math.min(game.distance / stages[game.stage].target, 1);
  pill(cx, 300, 40, 110, 8, 2, '#333', '#d0a000', 1);
  pill(cx, 300, 40, 110 * progress, 8, 2, '#d0a000', '#d0a000', 0);

  // Booster gauge (left side)
  pill(cx, 8, 66, 12, 60, 2, '#333', '#666', 1);
  const boostFill = (game.boost / 100) * 60;
  pill(cx, 8, 66 + 60 - boostFill, 12, boostFill, 2, '#00ff00', '#00aa00', 1);

  // Jump hint
  if (game.showJumpHint > 0) {
    cx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    cx.font = 'bold 12px Arial';
    cx.textAlign = 'center';
    cx.fillText('TAP TO JUMP', 210, 280);
    cx.textAlign = 'left';
  }
}

// Game physics & updates
function getGroundY(x) {
  const baseY = 540;
  const ox = game.ox * 0.4;
  return baseY + Math.sin((x + ox) * 0.005) * 8 +
                 Math.sin((x + ox) * 0.015) * 4 +
                 Math.sin((x + ox) * 0.04) * 2;
}

function checkUnlocks() {
  if (game.totalDistance >= 5000) rovers[1].unlocked = true;
  if (game.totalDistance >= 15000) rovers[2].unlocked = true;
}

function updateGame() {
  if (game.state !== 'play') return;

  const stageSpeed = stages[game.stage].speed;
  const scrollSpeed = 1.0 * stageSpeed;

  // Invincibility cooldown
  if (game.invincible > 0) game.invincible--;

  // Physics
  game.vy += 0.10;
  if (game.vy > 3.0) game.vy = 3.0;

  game.y += game.vy;
  const groundY = getGroundY(game.roverX);
  if (game.y + 25 >= groundY) {
    game.y = groundY - 25;
    game.vy = 0;
    game.onGround = true;
    if (game.boost < 100) game.boost += 0.25;
    if (game.boost > 100) game.boost = 100;
  } else {
    game.onGround = false;
  }

  // Scroll
  game.ox += scrollSpeed;
  game.distance += scrollSpeed / 6;

  // Spawn obstacles
  if (game.fr % Math.max(30, Math.floor(60 / stages[game.stage].obsMul)) === 0 && Math.random() < 0.7) {
    const type = ['rock', 'water', 'crater'][Math.floor(Math.random() * 3)];
    game.obstacles.push({ x: 420, type: type, h: 10 + Math.random() * 15 });
  }

  // Spawn crystals
  if (game.fr % Math.max(100, Math.floor(200 / stages[game.stage].enMul)) === 0 && Math.random() < 0.4) {
    game.crystals.push({ x: 420 });
  }

  // Move obstacles
  for (let i = game.obstacles.length - 1; i >= 0; i--) {
    game.obstacles[i].x -= scrollSpeed;
    if (game.obstacles[i].x < -30) {
      game.obstacles.splice(i, 1);
      continue;
    }

    const obs = game.obstacles[i];
    const baseY = 540;
    const ox = game.ox * 0.4;
    const oy = baseY + Math.sin((obs.x + ox) * 0.005) * 8 +
                       Math.sin((obs.x + ox) * 0.015) * 4 +
                       Math.sin((obs.x + ox) * 0.04) * 2 - obs.h;

    const hitbox = { x: game.roverX + 5, y: game.y + 5, w: 40, h: 25 };
    const obsbox = { x: obs.x, y: oy, w: 20, h: obs.h };

    if (hitbox.x < obsbox.x + obsbox.w && hitbox.x + hitbox.w > obsbox.x &&
        hitbox.y < obsbox.y + obsbox.h && hitbox.y + hitbox.h > obsbox.y) {
      if (game.invincible <= 0) {
        game.health--;
        game.invincible = 60; // ~1 second invincibility
        game.obstacles.splice(i, 1);
        if (game.health <= 0) {
          game.state = 'over';
          game.bestDistance = Math.max(game.bestDistance, game.distance);
          game.totalDistance += game.distance;
          game.currentFact = lunarFacts[Math.floor(Math.random() * lunarFacts.length)];
          checkUnlocks();
        }
      }
    }
  }

  // Move crystals
  for (let i = game.crystals.length - 1; i >= 0; i--) {
    game.crystals[i].x -= scrollSpeed;
    if (game.crystals[i].x < -30) {
      game.crystals.splice(i, 1);
      continue;
    }

    const cryst = game.crystals[i];
    const baseY = 540;
    const ox = game.ox * 0.4;
    const cy = baseY + Math.sin((cryst.x + ox) * 0.005) * 8 +
                       Math.sin((cryst.x + ox) * 0.015) * 4 +
                       Math.sin((cryst.x + ox) * 0.04) * 2 - 20;

    const hitbox = { x: game.roverX + 5, y: game.y + 5, w: 40, h: 25 };
    const cbox = { x: cryst.x - 8, y: cy - 10, w: 16, h: 20 };

    if (hitbox.x < cbox.x + cbox.w && hitbox.x + hitbox.w > cbox.x &&
        hitbox.y < cbox.y + cbox.h && hitbox.y + hitbox.h > cbox.y) {
      game.boost += 25;
      if (game.boost > 100) game.boost = 100;
      game.crystals.splice(i, 1);
    }
  }

  // Check stage clear
  if (game.distance >= stages[game.stage].target) {
    if (game.stage === 4) {
      game.state = 'victory';
    } else {
      game.state = 'clear';
    }
    game.bestDistance = Math.max(game.bestDistance, game.distance);
    game.totalDistance += game.distance;
    checkUnlocks();
  }

  game.showJumpHint--;
}

function drawGamePlay() {
  drawBg();
  drawGround();

  for (let obs of game.obstacles) {
    drawObstacle(obs);
  }
  for (let cryst of game.crystals) {
    drawCrystal(cryst);
  }

  // Blink rover during invincibility
  if (game.invincible > 0 && game.fr % 6 < 3) {
    cx.globalAlpha = 0.3;
  }
  drawRover(cx, rovers[game.roverId].key, game.roverX, game.y, 1);
  cx.globalAlpha = 1;
  drawHUD();
}

// Title screen
function drawTitle() {
  cx.fillStyle = '#000';
  cx.fillRect(0, 0, 420, 746);
  cx.fillStyle = '#d0a000';
  cx.font = 'bold 48px Arial';
  cx.textAlign = 'center';
  cx.fillText('MOON RUNNER', 210, 150);
  cx.font = 'bold 24px Arial';
  cx.fillText('Lunar Rover Adventure', 210, 190);

  drawRover(cx, 'sojourner', 140, 250, 1.5);
  drawRover(cx, 'curiosity', 160, 350, 1.5);
  drawRover(cx, 'perseverance', 150, 450, 1.5);

  cx.fillStyle = '#ffffff';
  cx.font = 'bold 16px Arial';
  cx.fillText('TAP TO START', 210, 630);
  cx.textAlign = 'left';
}

// Select rover screen
function drawSelect() {
  cx.fillStyle = '#1a1a2e';
  cx.fillRect(0, 0, 420, 746);

  cx.fillStyle = '#d0a000';
  cx.font = 'bold 32px Arial';
  cx.textAlign = 'center';
  cx.fillText('SELECT ROVER', 210, 50);

  const y_positions = [120, 340, 560];
  for (let i = 0; i < 3; i++) {
    const r = rovers[i];
    const y = y_positions[i];
    const selected = i === game.roverId;

    // Card border
    const color = selected ? '#ffff00' : r.color;
    pill(cx, 30, y, 360, 150, 10, '#222', color, selected ? 4 : 2);

    // Name
    cx.fillStyle = color;
    cx.font = 'bold 20px Arial';
    cx.textAlign = 'left';
    cx.fillText(r.name, 60, y + 30);

    // Stats
    cx.fillStyle = '#aaa';
    cx.font = 'bold 12px Arial';
    cx.fillText('SPD', 60, y + 50);
    cx.fillText('ARM', 150, y + 50);
    cx.fillText('BST', 240, y + 50);

    // Stat bars
    pill(cx, 60, y + 60, 60, 6, 2, '#333', '#666', 1);
    pill(cx, 60, y + 60, r.spd * 20, 6, 2, '#00ff00', '#00aa00', 0);

    pill(cx, 150, y + 60, 60, 6, 2, '#333', '#666', 1);
    pill(cx, 150, y + 60, r.arm * 15, 6, 2, '#ff6600', '#cc3300', 0);

    pill(cx, 240, y + 60, 60, 6, 2, '#333', '#666', 1);
    pill(cx, 240, y + 60, r.bst * 20, 6, 2, '#00ccff', '#0099cc', 0);

    // Locked/unlocked
    if (!r.unlocked) {
      cx.fillStyle = '#ff3030';
      cx.font = 'bold 14px Arial';
      cx.textAlign = 'center';
      cx.fillText('LOCKED', 210, y + 110);
      cx.textAlign = 'left';
    } else {
      drawRover(cx, r.key, 320, y + 10, 1);
    }
  }

  // Total distance
  cx.fillStyle = '#888';
  cx.font = 'bold 14px Arial';
  cx.textAlign = 'center';
  cx.fillText('TOTAL DISTANCE: ' + Math.floor(game.totalDistance) + 'm', 210, 720);
  cx.textAlign = 'left';
}

// Stage map screen
function drawStageMap() {
  cx.fillStyle = '#000';
  cx.fillRect(0, 0, 420, 746);

  cx.fillStyle = '#d0a000';
  cx.font = 'bold 28px Arial';
  cx.textAlign = 'center';
  cx.fillText('MISSION MAP', 210, 50);

  // Moon circle
  circle(cx, 210, 280, 100, '#e8e0d0', '#a09888', 3);

  // Crater details
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    const x = 210 + Math.cos(angle) * 70;
    const y = 280 + Math.sin(angle) * 70;
    cx.fillStyle = '#8a7a6a';
    cx.beginPath();
    cx.arc(x, y, 8, 0, Math.PI * 2);
    cx.fill();
  }

  // Stage markers
  const positions = [
    { x: 210, y: 210 },
    { x: 290, y: 230 },
    { x: 310, y: 310 },
    { x: 260, y: 360 },
    { x: 160, y: 350 },
  ];

  // Path
  cx.strokeStyle = '#666';
  cx.lineWidth = 2;
  cx.setLineDash([5, 5]);
  cx.beginPath();
  cx.moveTo(positions[0].x, positions[0].y);
  for (let i = 1; i < 5; i++) {
    cx.lineTo(positions[i].x, positions[i].y);
  }
  cx.stroke();
  cx.setLineDash([]);

  // Dots
  for (let i = 0; i < 5; i++) {
    const pos = positions[i];
    if (i < game.stage) {
      // Completed
      circle(cx, pos.x, pos.y, 12, '#d0a000', '#a08000', 2);
      cx.fillStyle = '#000';
      cx.font = 'bold 16px Arial';
      cx.textAlign = 'center';
      cx.fillText('\u2713', pos.x, pos.y + 6);
    } else if (i === game.stage) {
      // Active (pulsing)
      const pulse = Math.sin(game.fr * 0.1) * 0.3 + 0.7;
      circle(cx, pos.x, pos.y, 12 * pulse, stages[i].color, '#fff', 2);
      cx.fillStyle = stages[i].color;
      cx.font = 'bold 14px Arial';
      cx.textAlign = 'center';
      cx.fillText((i + 1), pos.x, pos.y + 5);
    } else {
      // Locked
      circle(cx, pos.x, pos.y, 10, '#666', '#333', 2);
      cx.fillStyle = '#333';
      cx.font = 'bold 12px Arial';
      cx.textAlign = 'center';
      cx.fillText((i + 1), pos.x, pos.y + 4);
    }
    cx.textAlign = 'left';
  }

  // Stage info
  const stage = stages[game.stage];
  cx.fillStyle = stage.color;
  cx.font = 'bold 20px Arial';
  cx.textAlign = 'center';
  cx.fillText(stage.name, 210, 480);
  cx.fillStyle = '#aaa';
  cx.font = 'bold 14px Arial';
  cx.fillText(stage.sub, 210, 505);

  cx.fillStyle = '#fff';
  cx.font = 'bold 12px Arial';
  cx.fillText('DIFFICULTY: ' + stage.diff, 210, 530);
  cx.fillText('TARGET: ' + stage.target + 'm', 210, 550);

  // Prompt
  const blink = Math.sin(game.fr * 0.1) > 0 ? 1 : 0.3;
  cx.fillStyle = 'rgba(208, 160, 0, ' + blink + ')';
  cx.font = 'bold 14px Arial';
  cx.fillText('TAP TO START MISSION', 210, 620);
  cx.textAlign = 'left';
}

// Game over screen
function drawGameOver() {
  cx.fillStyle = '#000';
  cx.fillRect(0, 0, 420, 746);

  cx.fillStyle = '#ff3030';
  cx.font = 'bold 40px Arial';
  cx.textAlign = 'center';
  cx.strokeStyle = '#660000';
  cx.lineWidth = 3;
  cx.strokeText('MISSION ENDED', 210, 80);
  cx.fillText('MISSION ENDED', 210, 80);

  // Stats
  cx.fillStyle = '#fff';
  cx.font = 'bold 16px Arial';
  cx.fillText('DISTANCE: ' + Math.floor(game.distance) + 'm', 210, 140);
  cx.fillText('BEST: ' + Math.floor(game.bestDistance) + 'm', 210, 165);

  // TCG Card
  const cardX = 40, cardY = 200, cardW = 340, cardH = 280;

  // Outer purple border with glow
  cx.fillStyle = 'rgba(64, 40, 160, 0.3)';
  cx.fillRect(cardX - 5, cardY - 5, cardW + 10, cardH + 10);

  cx.fillStyle = '#4028a0';
  cx.fillRect(cardX, cardY, cardW, cardH);

  // Gold gradient frame
  const gf = cx.createLinearGradient(cardX, cardY, cardX + cardW, cardY + cardH);
  gf.addColorStop(0, '#ffcc00');
  gf.addColorStop(0.5, '#d4a000');
  gf.addColorStop(1, '#ffcc00');
  cx.fillStyle = gf;
  cx.fillRect(cardX + 5, cardY + 5, cardW - 10, 3);
  cx.fillRect(cardX + 5, cardY + cardH - 8, cardW - 10, 3);

  // Hexagon cost badge
  cx.fillStyle = '#d0a000';
  cx.beginPath();
  const cx_b = cardX + 20, cy_b = cardY + 20, r_b = 12;
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    const x = cx_b + Math.cos(angle) * r_b;
    const y = cy_b + Math.sin(angle) * r_b;
    if (i === 0) cx.moveTo(x, y);
    else cx.lineTo(x, y);
  }
  cx.closePath();
  cx.fill();
  cx.fillStyle = '#000';
  cx.font = 'bold 14px Arial';
  cx.textAlign = 'center';
  cx.fillText('\ud83c\udf19', cx_b, cy_b + 5);

  // Fact text (stored when entering game over state)
  const fact = game.currentFact || lunarFacts[0];

  // Illustration window
  cx.fillStyle = '#a09888';
  cx.fillRect(cardX + 15, cardY + 45, cardW - 30, 80);
  // Simple moon scene
  circle(cx, cardX + 80, cardY + 65, 15, '#e8e0d0', '#999', 1);
  drawRover(cx, rovers[game.roverId].key, cardX + 130, cardY + 80, 0.7);

  // Card name
  cx.fillStyle = '#d0a000';
  cx.font = 'bold 12px Arial';
  cx.textAlign = 'left';
  cx.fillText(fact.title || 'LUNAR WONDER', cardX + 15, cardY + 150);

  // Type line
  cx.fillStyle = '#999';
  cx.font = '11px Arial';
  cx.fillText(fact.type || 'LUNAR FACT', cardX + 15, cardY + 165);
  cx.fillStyle = '#ddd';
  cx.font = 'bold 10px Arial';
  cx.textAlign = 'center';
  const words = fact.text.split(' ');
  let line = '';
  let yoff = 0;
  for (let w of words) {
    if ((line + w).length > 30) {
      cx.fillText(line, 210, cardY + 180 + yoff);
      yoff += 12;
      line = w + ' ';
    } else {
      line += w + ' ';
    }
  }
  if (line) cx.fillText(line, 210, cardY + 180 + yoff);

  cx.font = '9px Arial';
  cx.fillStyle = '#999';
  cx.fillText(fact.type, 210, cardY + 240);

  // Retry button
  pill(cx, 130, 520, 160, 40, 5, '#d0a000', '#a08000', 2);
  cx.fillStyle = '#000';
  cx.font = 'bold 16px Arial';
  cx.textAlign = 'center';
  cx.fillText('TAP TO RETRY', 210, 548);
  cx.textAlign = 'left';
}

// Clear screen
function drawClear() {
  cx.fillStyle = '#000';
  cx.fillRect(0, 0, 420, 746);

  const stage = stages[game.stage];
  cx.fillStyle = stage.color;
  cx.font = 'bold 48px Arial';
  cx.textAlign = 'center';
  cx.strokeStyle = '#000';
  cx.lineWidth = 3;
  cx.strokeText('STAGE CLEAR!', 210, 150);
  cx.fillText('STAGE CLEAR!', 210, 150);

  cx.fillStyle = '#fff';
  cx.font = 'bold 24px Arial';
  cx.fillText(stage.name, 210, 200);

  cx.fillStyle = '#d0a000';
  cx.font = 'bold 18px Arial';
  cx.fillText('DISTANCE: ' + Math.floor(game.distance) + 'm', 210, 280);

  // Gold badge with stage number
  circle(cx, 210, 380, 40, '#ffcc00', '#d0a000', 3);
  cx.fillStyle = '#000';
  cx.font = 'bold 32px Arial';
  cx.textAlign = 'center';
  cx.fillText((game.stage + 1), 210, 395);

  cx.fillStyle = '#fff';
  cx.font = 'bold 14px Arial';
  cx.fillText('TAP FOR NEXT STAGE', 210, 550);
  cx.textAlign = 'left';
}

// Victory screen
function drawVictory() {
  cx.fillStyle = '#000';
  cx.fillRect(0, 0, 420, 746);

  cx.fillStyle = '#ffff00';
  cx.font = 'bold 52px Arial';
  cx.textAlign = 'center';
  cx.strokeStyle = '#000';
  cx.lineWidth = 4;
  cx.strokeText('MISSION COMPLETE!', 210, 150);
  cx.fillText('MISSION COMPLETE!', 210, 150);

  cx.fillStyle = '#d0a000';
  cx.font = 'bold 18px Arial';
  cx.fillText('ALL LUNAR REGIONS CONQUERED', 210, 200);
  cx.fillText('TOTAL DISTANCE: ' + Math.floor(game.distance) + 'm', 210, 280);

  // Gold star
  drawCuteStar(cx, 210, 380, 50, '#ffff00', '#d0a000');

  cx.fillStyle = '#fff';
  cx.font = 'bold 14px Arial';
  cx.fillText('TAP TO RETURN TO TITLE', 210, 600);
  cx.textAlign = 'left';
}

// Main draw
function draw() {
  if (game.state === 'title') {
    drawTitle();
  } else if (game.state === 'select') {
    drawSelect();
  } else if (game.state === 'stageMap') {
    drawStageMap();
  } else if (game.state === 'play') {
    drawGamePlay();
  } else if (game.state === 'over') {
    drawGameOver();
  } else if (game.state === 'clear') {
    drawClear();
  } else if (game.state === 'victory') {
    drawVictory();
  }
}

// Input
function startGame() {
  game.state = 'play';
  game.ox = 0;
  game.distance = 0;
  game.health = 3;
  game.boost = 100;
  game.vy = 0;
  game.y = 540 - 25; // ground level minus rover height
  game.obstacles = [];
  game.crystals = [];
  game.onGround = true;
  game.jumps = 0;
  game.invincible = 0;
  game.showJumpHint = 120;
  game.currentFact = lunarFacts[Math.floor(Math.random() * lunarFacts.length)];
}

document.addEventListener('pointerdown', (e) => {
  if (game.state === 'title') {
    game.state = 'select';
  } else if (game.state === 'select') {
    if (rovers[game.roverId].unlocked) {
      game.stage = 0;
      game.state = 'stageMap';
    }
  } else if (game.state === 'stageMap') {
    startGame();
  } else if (game.state === 'play') {
    if (game.onGround) {
      game.vy = -5.0;
      game.onGround = false;
    } else if (game.boost >= 20) {
      game.vy = -3.5;
      game.boost -= 20;
    }
  } else if (game.state === 'over') {
    game.state = 'select';
  } else if (game.state === 'clear') {
    game.stage++;
    game.state = 'stageMap';
  } else if (game.state === 'victory') {
    game.state = 'title';
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    if (game.state === 'select') {
      game.roverId = (game.roverId - 1 + 3) % 3;
      return;
    }
  }
  if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
    if (game.state === 'select') {
      game.roverId = (game.roverId + 1) % 3;
      return;
    }
  }
  if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'Enter') {
    e.preventDefault();
    if (game.state === 'title') {
      game.state = 'select';
    } else if (game.state === 'select') {
      if (rovers[game.roverId].unlocked) {
        game.stage = 0;
        game.state = 'stageMap';
      }
    } else if (game.state === 'stageMap') {
      startGame();
    } else if (game.state === 'play') {
      if (game.onGround) {
        game.vy = -5.0;
        game.onGround = false;
      } else if (game.boost >= 20) {
        game.vy = -3.5;
        game.boost -= 20;
      }
    } else if (game.state === 'over') {
      game.state = 'select';
    } else if (game.state === 'clear') {
      game.stage++;
      game.state = 'stageMap';
    } else if (game.state === 'victory') {
      game.state = 'title';
    }
  }
});

// Game loop
function gameLoop() {
  game.fr++;
  updateGame();
  draw();
  requestAnimationFrame(gameLoop);
}

// Initialize
game.obstacles = [];
game.crystals = [];
game.onGround = true;
game.y = 540 - 25;
game.invincible = 0;
game.currentFact = lunarFacts[0];

// Unlock logic on completion
game.bestDistance = 0;
game.totalDistance = 0;

gameLoop();
  </script>
</body>
</html>